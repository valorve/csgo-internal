#include "exploits.hpp"
#include "../../game/engine_prediction.hpp"
#include "../../globals.hpp"
#include "../../hooks/hooker.hpp"
#include "../../hooks/hooks.hpp"
#include "../../interfaces.hpp"
#include "../../utils/hotkeys.hpp"
#include "../movement.hpp"
#include "hvh.hpp"
#include "peek_state.hpp"

namespace hvh {
	using namespace sdk;

	STFI void reset_exploits() {
		exploits->m_recharge_ticks = 0;
		exploits->m_shift_ticks = 0;
		exploits->m_shift_cmd = 0;
	}

	STFI void adjust_shift(int command_number, int amount) {
		auto& entry = engine_prediction->m_entries[command_number % max_input];

		if (command_number != entry.m_sequence) {
			entry.m_sequence = command_number;
			entry.m_shift = 0;
		}

		entry.m_shift += amount;
	}

	STFI void update_exploit_type() {
		if (globals->m_fake_duck) {
			exploits->m_type = exploits_t::e_type::none;
			return;
		}

		if (hotkeys->doubletap.m_active)
			exploits->m_type = exploits_t::e_type::doubletap;
		else if (!hotkeys->doubletap.m_active && hotkeys->hide_shot.m_active)
			exploits->m_type = exploits_t::e_type::hideshot;
		else
			exploits->m_type = exploits_t::e_type::none;
	}

	STFI int get_limit() {
		return CVAR_INT("sv_maxusrcmdprocessticks") - 2;
	}

	STFI bool can_recharge() {
		const auto time_delta = TICKS_TO_TIME(std::abs(interfaces::client_state->get_current_tick() - exploits->m_last_shift_tick));
		const auto shift_time_expires = time_delta > 0.2f;

		if (exploits->m_type != exploits_t::e_type::none && exploits->m_old_type == exploits_t::e_type::none)
			return shift_time_expires;

		if (hotkeys->peek_assist.m_active)
			return (!movement->m_peek_state.m_going_back || time_delta > 0.5f) && time_delta > 0.1f;

		const auto shot_time_expires =
				std::abs(interfaces::global_vars->m_curtime - globals->m_weapon->last_shot_time()) >= 0.2f + TICKS_TO_TIME(CVAR_INT("sv_maxusrcmdprocessticks"));

		const auto weapon_id = globals->m_weapon->item_definition_index();
		const auto is_sniper = weapon_id == e_weapon_type::weapon_ssg08 || weapon_id == e_weapon_type::weapon_awp;
		const auto is_peeking = std::any_of(peek_state->m_players, peek_state->m_players + 64, [](const auto& p) { return p.m_has_damage || p.m_has_damage_old; });
		const auto danger = is_peeking || aimbot->m_should_predictive_stop || aimbot->m_last_target != nullptr;

		return !danger && shift_time_expires && shot_time_expires && !exploits->m_charged && exploits->m_recharge_ticks == 0;
	}

	STFI void update_charge() {
		if (globals->m_fake_duck)
			return;

		switch (exploits->m_type) {
			default: return reset_exploits();
			case exploits_t::e_type::doubletap:
				if (can_recharge())
					exploits->m_recharge_ticks = get_limit();
				break;
			case exploits_t::e_type::hideshot:
				if (can_recharge())
					exploits->m_recharge_ticks = get_limit();
				break;
		}
	}

	STFI void update_shift() {
		if (exploits->m_type == exploits->m_old_type)
			return;

		const auto first_charge = exploits->m_type == exploits_t::e_type::none && exploits->m_old_type != exploits_t::e_type::none;
		if (exploits->m_charged) {
			switch (exploits->m_old_type) {
				case exploits_t::e_type::doubletap:
					if (first_charge)
						exploits->m_shift_ticks = get_limit();
					break;
				case exploits_t::e_type::hideshot:
					if (first_charge)
						exploits->m_shift_ticks = get_limit();
					break;
			}
		}
	}

	int exploits_t::get_exploit_bullets() {
		if (globals->m_weapon == nullptr)
			return 1;

		auto weapon_info = globals->m_weapon->get_cs_weapon_info();
		if (weapon_info == nullptr)
			return 1;

		return (int)(TICKS_TO_TIME(CVAR_INT("sv_maxusrcmdprocessticks")) / weapon_info->m_cycle_time) + 1;
	}

	STFI void store_tickbase(int value, int command_number, int shift_amount, bool restore_tickbase, int command_diff = 1) {
		auto& tickbase = exploits->m_tickbase;
		tickbase.m_value = value;
		tickbase.m_command_number = command_number;
		tickbase.m_shift_amount = shift_amount;
		tickbase.m_restore_tickbase = restore_tickbase;
		tickbase.m_command_diff = command_diff;
	}

	void exploits_t::fix_tickbase(user_cmd_t* cmd) {
		auto& tickbase = globals->m_local->tickbase();
		auto viewmodel = (base_viewmodel_t*)globals->m_local->viewmodel_handle().get();
		if (viewmodel == nullptr)
			return;

		if (m_tickbase.m_command_number == cmd->m_command_number) {
			viewmodel->animtime() -= TICKS_TO_TIME(m_tickbase.m_shift_amount + interfaces::global_vars->m_simticks_this_frame);
			tickbase = m_tickbase.m_value - m_tickbase.m_shift_amount + interfaces::global_vars->m_simticks_this_frame;
			cmd->m_has_been_predicted = true;
		}

		if (m_tickbase.m_restore_tickbase && m_tickbase.m_command_number + m_tickbase.m_command_diff == cmd->m_command_number) {
			viewmodel->animtime() += TICKS_TO_TIME(m_tickbase.m_shift_amount - interfaces::global_vars->m_simticks_this_frame);
			tickbase += m_tickbase.m_shift_amount - interfaces::global_vars->m_simticks_this_frame;
			cmd->m_has_been_predicted = true;
		}
	}

	STFI void fake_duck(user_cmd_t* cmd) {
		static bool start = true;
		if (interfaces::game_rules->is_valve_ds() || interfaces::game_rules->is_freeze_time()) {
			globals->m_fake_duck = false;
			start = true;
			return;
		}

		if (globals->m_local->flags().has(fl_frozen) || globals->m_groundtick <= 1) {
			globals->m_fake_duck = false;
			start = true;
			return;
		}

		if (hotkeys->fake_duck.m_active) {
			globals->m_fake_duck = true;

			if (start) {
				const bool new_send_packet = interfaces::client_state->m_choked_commands >= 1;
				if (*globals->m_send_packet != new_send_packet) {
					*globals->m_send_packet = new_send_packet;
					antiaim->apply(cmd);
				}

				if (interfaces::client_state->m_choked_commands > 0)
					return;
				else
					cmd->m_buttons.remove(in_duck);

				//engine_prediction->repredict(cmd);

				start = false;
				return;
			}

			if (interfaces::client_state->m_choked_commands < 7)
				cmd->m_buttons.remove(in_duck);
			else
				cmd->m_buttons.add(in_duck);

			//engine_prediction->repredict(cmd);
			*globals->m_send_packet = interfaces::client_state->m_choked_commands >= MAX_FAKELAG;
		} else {
			if (!globals->m_local->ducking())
				globals->m_fake_duck = false;

			start = true;
		}
	}

	STFI void perform_shift(user_cmd_t* cmd, int ticks) {
		exploits->m_shift_ticks = ticks;
		exploits->m_shift_cmd = 0;
		exploits->m_dt_shots = 1;
	}

	STFI void break_lc(user_cmd_t* cmd, int current_command, int limit) {
		const auto doubletap = exploits->m_type == exploits_t::e_type::doubletap;

		if (!settings->exploits.immediate_teleport) {
			if (doubletap) {
				if (exploits->m_shot_in_queue && exploits->m_shift_ticks == 0 && std::abs(current_command - exploits->m_last_skip_peek) >= limit) {
					cmd->m_buttons.remove(in_attack);
					perform_shift(cmd, limit);

					//if (settings->exploits.defensive_flags.at(2) && hotkeys->peek_assist.m_active)
					//	movement->m_peek_state.m_going_back = true;

					exploits->m_shot_in_queue = false;
					return;
				}
			}
		}

		exploits->m_shift_cmd = limit;

		if (*globals->m_send_packet) {
			auto skip_current_shift = false;

			const auto ground_trigger = settings->exploits.defensive_flags.at(0) && globals->m_groundtick > 1;
			const auto air_trigger = settings->exploits.defensive_flags.at(1) && globals->m_airtick > 1;

			if ((ground_trigger || air_trigger || exploits->m_type == exploits_t::e_type::hideshot) && !peek_state->m_defensive_lag) {
				if (std::abs(current_command - exploits->m_last_skip) > limit)
					skip_current_shift = true;
			}

			if (!skip_current_shift) {
				const auto diff = std::abs(current_command - exploits->m_last_skip_peek);
				if (peek_state->m_defensive_lag && diff > limit) {
					skip_current_shift = true;
					exploits->m_last_skip_peek = current_command + 1;

					//if (doubletap && settings->exploits.defensive_flags.at(2) && hotkeys->peek_assist.m_active)
					//	exploits->m_shot_in_queue = true;
				}
			}

			if (skip_current_shift) {
				exploits->m_shift_cmd = 0;
				exploits->m_last_skip = current_command + 1;

				store_tickbase(globals->m_local->tickbase(), cmd->m_command_number, -exploits->m_tickbase.m_simulation_ticks + 2, true);
				adjust_shift(interfaces::client_state->m_last_outgoing_command + 1, limit);
				adjust_shift(interfaces::client_state->get_current_tick() + 1, -limit);
			}
		}
	}

	STFI void double_tap(user_cmd_t* cmd) {
		const auto limit = get_limit();
		const auto current_command = interfaces::client_state->get_current_tick() - 1;
		const auto is_revolver = globals->m_weapon->item_definition_index() == e_weapon_type::weapon_revolver;
		const auto is_valid_weapon = (globals->m_weapon->is_gun() && !is_revolver) || globals->m_weapon->is_knife();

		if (!is_valid_weapon)
			return;

		if (!is_shooting(cmd))
			return break_lc(cmd, current_command, limit);

		if (!settings->exploits.immediate_teleport) {
			auto weapon_info = globals->m_weapon->get_cs_weapon_info();
			if (weapon_info != nullptr && weapon_info->m_cycle_time > 0.4f || hotkeys->peek_assist.m_active) {
				if (std::abs(current_command - exploits->m_last_skip_peek) < limit) {
					if (!(*globals->m_send_packet) || exploits->m_last_shift_cmd == 0) {
						if (cmd->m_buttons.has(in_attack)) {
							cmd->m_buttons.remove(in_attack);
							antiaim->apply(cmd);
						}
					} else
						exploits->m_shot_in_queue = true;

					return break_lc(cmd, current_command, limit);
				}
			}
		}

		if (interfaces::client_state->m_choked_commands >= 1) {
			cmd->m_buttons.remove(in_attack);
			antiaim->apply(cmd);
			return break_lc(cmd, current_command, limit);
		}

		perform_shift(cmd, limit);
	}

	STFI void hide_shot(user_cmd_t* cmd) {
		if (!globals->m_weapon->is_gun() || globals->m_weapon->item_definition_index() == e_weapon_type::weapon_revolver)
			return;

		const auto limit = get_limit();
		const auto current_command = interfaces::client_state->get_current_tick() - 1;

		if (!is_shooting(cmd))
			return break_lc(cmd, current_command, limit);

		if (std::abs(current_command - exploits->m_last_skip) < limit && (!(*globals->m_send_packet) || exploits->m_last_shift_cmd == 0)) {
			if (cmd->m_buttons.has(in_attack)) {
				cmd->m_buttons.remove(in_attack);
				antiaim->apply(cmd);
				return break_lc(cmd, current_command, limit);
			}
		}

		//if (is_able_to_shoot(globals->m_local->tickbase() - XOR32(shift)) && *globals->m_send_packet) {
		//	//*globals->m_send_packet = true;
		//	//exploits->m_shift_cmd = shift;
		//}
	}

	void exploits_t::on_create_move(user_cmd_t* cmd) {
		m_last_skip_shift = false;

		update_exploit_type();

		if (m_type != m_old_type || m_need_recharge)
			update_charge();

		update_shift();
		if (m_charged) {
			switch (m_type) {
				case e_type::doubletap: double_tap(cmd); break;
				case e_type::hideshot: hide_shot(cmd); break;
			}
		}

		if (m_charged && m_shift_cmd == 0)
			exploits->m_last_skip_shift = true;

		m_breaking_lc = false;
		{
			static int timer{};
			if (m_charged && m_type != exploits_t::e_type::none) {
				if (timer == -1 && m_shift_cmd > 0)
					timer = m_shift_cmd;

				if (timer > 0) {
					if (m_shift_cmd > 0) {
						m_breaking_lc = true;
						--timer;
					} else
						timer = *globals->m_send_packet ? -1 : 0;
				} else {
					if (m_shift_cmd == 0 && *globals->m_send_packet)
						timer = m_last_shift_cmd > 0 ? -1 : 0;
				}
			} else
				timer = 0;
		}

		if (m_shift_ticks > 0) {
			if (globals->m_weapon->item_definition_index() == e_weapon_type::weapon_revolver)
				cmd->m_buttons.remove(in_attack);

			*globals->m_send_packet = true;
			antiaim->apply(cmd);
			*globals->m_send_packet = interfaces::client_state->m_choked_commands >= 1;

			if ((*globals->m_send_packet))
				m_shift_cmd = get_limit();
		} else
			antiaim->apply(cmd);

		m_old_type = m_type;
		m_last_shift_cmd = m_shift_cmd;

		fake_duck(cmd);
	}

	STFI void store_values(exploits_t::ping_backup_t& p) {
		p.m_curtime = interfaces::global_vars->m_curtime;
		p.m_frametime = interfaces::global_vars->m_frametime;
		p.m_tickcount = interfaces::global_vars->m_tickcount;
		p.m_cs_frametime = interfaces::client_state->m_frametime;
	}

	STFI void apply_values(const exploits_t::ping_backup_t& p) {
		interfaces::global_vars->m_curtime = p.m_curtime;
		interfaces::global_vars->m_frametime = p.m_frametime;
		interfaces::global_vars->m_tickcount = p.m_tickcount;
		interfaces::client_state->m_frametime = p.m_cs_frametime;
	}

	STFI bool can_store_packets() {
		if (!globals->m_is_connected)
			return false;

		auto net_channel = interfaces::engine->get_net_channel();
		if (net_channel == nullptr)
			return false;

		if (net_channel->is_loopback())
			return false;

		return true;
	}

	bool exploits_t::can_read_packets() {
		if (!can_store_packets())
			return false;

		store_values(exploits->m_ping_data);
		return true;
	}

	void exploits_t::on_cl_move(bool final_tick) {
		if (!can_store_packets())
			return;

		static auto read_packets = detour->original(&hooks::engine::read_packets);

		ping_backup_t backup{};
		store_values(backup);
		read_packets(final_tick);
		store_values(exploits->m_ping_data);
		apply_values(backup);
	}

	void exploits_t::on_post_shift() {
		m_in_shift = false;
		m_last_shift_tick = interfaces::client_state->get_current_tick();
		m_need_recharge = true;
		m_charged = false;
		m_shift_ticks = 0;
		m_shot_in_queue = false;
		m_charged_ticks = 0;
	}
} // namespace hvh